---
layout: post
toc: true
math: false
title: "npm에 대하여"
categories: ["programming"]
tags: [npm, javascript]
author:
  - 이현재
---

<p align="center">
  <img src="/img/2022-02-11-about-npm/npm-logo.svg">
</p>

Node Package Manager, npm은 NodeJS 패키지 매니저로서 패키지 설치, 의존성 관리의 역할을 수행합니다.
<!--more-->
JS 개발자로서 매일 같이 유용하게 쓰고 있음에도 불구하고 npm에 대해 마음을 다잡고 공부해 본 적이 없어서
이 포스트를 쓰게 되었습니다. npm의 기능을 중심으로 훑어가도록 하겠습니다.

# 1. 의존성 관리
npm에서는 패키지의 이름, 작성자, 설명과 의존성 관리 등을 `package.json`을 통해 관리하고 있습니다.
`npm init`을 하면 프로젝트 루트 폴더에 생기는 바로 그 파일인데, 여기에 패키지에 대한 정보를 json 형태로
저장하게 됩니다. `package.json`은 사람 뿐만 아니라 npm에서도 패키지 정보를 얻기 위해 활용하기 때문에
지우면 안됩니다.

> 참고로 `npm ls`를 실행하면 의존성 패키지 목록을 훑어볼 수 있습니다. 여기에 `--depth <Number>` 파라미터를
> 넘겨주면 의존 패키지가 또 의존하는 패키지를 해당 깊이만큼 트리 형태로 볼 수 있습니다.

## 버전 명세
NodeJS 패키지들은 `x.y.z`와 같이 세 개의 숫자로 구성된 버전 형식을 사용하는데, 이를
*Semantic Versioning*이라 합니다. 년-월-일과 같이 세 숫자는 메이저-마이너-패치의 의미를 가지고 있습니다.
왼쪽으로 갈수록 패키지가 많이 다르다는 뜻이죠. 버그 픽스를 반영했으면 `z`를 바꾸고, 기능이 추가되면서
전 버전과 호환되면 `y`를, 전 버전과 호환이 안 되거나 그 만큼의 기능이 바뀌었으면 `x`를 바꿔주는 방법으로
버전을 정하면 됩니다. 

물론 이를 반드시 지키지 않아도 되고 실제로 지키지 않아도 npm에 패키지 업로드는 잘 됩니다만, 이를 지켜주는게
좋습니다. npm에서 의존성 관리를 할 때 의존하고 있는 패키지 버전을 위 규칙을 기반으로 관리하기 때문입니다.

패키지를 설치하고 `package.json`에 들어가면 dependencies 또는 devdependencies에 의존 패키지 이름과
함께 버전이 적혀 있는데 버전만 적혀있는 것이 아니라 `^x.y.z`, `>=x.y.z`와 같이 특수문자를 포함해서
적혀있는 것을 보셨을 겁니다. 사용할 수 있는 특수문자와 그 의미는 아래와 같습니다.

**^**<br>
`^x.y.z`와 같이 쓰며 가장 왼쪽의 0이 아닌 값을 바꾸지 않는 선에서 사용 가능.
예를 들어 `^1.0.0`일 때 `1.0.1`, `1.1.0`으로 업데이트는 가능하지만 `2.0.0`으로는 업데이트 하지 않습니다.
또 `^0.3.0`이면 `0.3.1`과 `0.3.2`는 가능하지만 `0.4.0`은 불가능합니다.

**~**<br>
`~x.y.z`와 같이 쓰며 `z` 버전만 바꾸는 선에서 사용 가능. 예를 들어 `~1.0.0`일 때 `1.0.1`은 가능하지만
`1.1.0`은 불가능합니다.

**>**<br>
`>x.y.z`와 같이 쓰며 `x.y.z`보다 높은 버전을 명시하기 위해 사용합니다.

**>=**<br>
`>=x.y.z`와 같이 쓰며 `x.y.z` 이상의 버전을 명시하기 위해 사용합니다.

**<**<br>
`<x.y.z`와 같이 쓰며 `x.y.z`보다 낮은 버전을 명시하기 위해 사용합니다.

**<=**<br>
`<=x.y.z`와 같이 쓰며 `x.y.z` 이하의 버전을 명시하기 위해 사용합니다.

**=**<br>
`=x.y.z`와 같이 쓰며 `x.y.z` 버전 만을 명시하기 위해 사용합니다. `x.y.z`와 같은 효과를 가집니다.

**-**<br>
`a.b.c - x.y.z`와 같이 쓰며 범위를 지정할 때 사용합니다. 이 때 범위는 양쪽 inclusive 입니다.

**||**<br>
`<...> || <...>`와 같이 쓰며 두 명세를 조합할 때 (OR) 쓸 때 사용합니다. 예를 들어 `0.1.0 || ^1.0.0`은
`0.1.0` 버전과 `1.y.z` 버전을 명시할 수 있습니다.


## dependencies vs. devDependencies
npm 패키지에서 의존성들은 dependencies와 devDependencies로 관리합니다. 패키지 실행 시 필요한 (런타임)
의존성들은 dependencies로, 그 외 개발에 필요한 패키지들은 devDependencies로 가는 식으로 나눠주죠.

> 일일이 `package.json`에 들어가 분리할 필요 없이
> `npm i <Package Name>`에 `--save` (또는 `-S`) 플래그를 붙이면 dependencies로, 
> `npm i <Package Name>`에 `--save-dev` (또는 `-D`) 플래그를 붙이면 devDependencies로 알아서
> npm이 분리해줍니다.

예를 들어 eslint로 코드 컨벤션을 관리하며 express.JS로 백엔드 서버를 제작했다고 합시다.
eslint는 런타임에는 전혀 필요가 없고 서버를 돌릴 때 코드 컨벤션은 맞춰줄 필요가 없으니 devDependencies로,
express.JS는 서버 런타임 동작 시 필요하니 dependencies로 지정하는 것이 적합하겠죠.

그런데 `npm install` (또는 `npm i`) 명령어를 통해 의존성 패키지를 설치 시 dependencies 뿐만 아니라
devDependencies도 함께 설치됨을 알 수 있습니다. 어차피 둘 다 한꺼번에 설치되는데 왜 굳이 분리하는 걸까요?

이는 우리가 제작한 패키지가 다른 패키지에 의해 참조될 때를 위한 것입니다. 우리가 git을 통해 패키지를 내려 받고
제작하는 것은 해당 패키지를 직접 뜯어 고치는 작업입니다. 이미 우리가 해당 패키지를 개발한다는 의미를 지니고 있기에
인스톨 명령 시 두 의존성을 다 설치하는 것이죠.

하지만 다른 패키지가 우리 패키지에 의존할 시에는 상황이 다릅니다. 우리 패키지가 필요한 것이지, 직접 뜯어 고치고
싶지는 않을테죠. 다시 위의 express.JS 백엔드 서버를 예를 들어봅시다. 누군가가 우리의 백엔드 서버를 필요로 해서
의존성으로 설치할 시 express.JS는 dependencies에 명시되어 있기에 자동적으로 설치되겠지만 eslint는 설치되지
않을 것입니다. devDependencies에 명시되어 있으니까요.

## peerdependencies

## package-lock

# 2. npm Command
`npm <Command>` 명령어로 npm에서 지원하는 명령을 실행할 수 있습니다.
## 기본 Scripts


# 3. npm vs. yarn


# 4. 참조
> [https://docs.npmjs.com/about-semantic-versioning](https://docs.npmjs.com/about-semantic-versioning)
> 
> [https://nodejs.dev/learn/semantic-versioning-using-npm](https://nodejs.dev/learn/semantic-versioning-using-npm)
>
> [https://semver.npmjs.com/](https://semver.npmjs.com/)
